<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scripts | SPEAC | Hans Rutger Bosker</title>
    <link>https://hrbosker.github.io/resources/scripts/</link>
      <atom:link href="https://hrbosker.github.io/resources/scripts/index.xml" rel="self" type="application/rss+xml" />
    <description>Scripts</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Thu, 07 Jul 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://hrbosker.github.io/resources/scripts/featured.jpg</url>
      <title>Scripts</title>
      <link>https://hrbosker.github.io/resources/scripts/</link>
    </image>
    
    <item>
      <title>Save all</title>
      <link>https://hrbosker.github.io/resources/scripts/save-all/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/save-all/</guid>
      <description>&lt;p&gt;Praat can only save one object at a time for you. If you have multiple objects in your object window you&amp;rsquo;d like to save in one go, you can use this script. It can either save objects by their object name or by their id number.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../save-all.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@ru.nl
### Date: 23 June 2022, run in Praat 6.2.12 on Windows 10
### License: CC BY-NC 4.0
################################################################################

	###&amp;gt;&amp;gt; This script saves all selected objects to the directory &amp;#39;dir_out$&amp;#39;
	###&amp;gt;&amp;gt;	with either:
	###&amp;gt;&amp;gt;   - their object name (e.g., &amp;#34;sentence1.wav&amp;#34;)
	###&amp;gt;&amp;gt;			&amp;gt; set variable &amp;#39;save_method$&amp;#39; to &amp;#34;name&amp;#34; [default]
	###&amp;gt;&amp;gt;   - their id number in the Praat object window (e.g., &amp;#34;42.wav&amp;#34;)
	###&amp;gt;&amp;gt;			&amp;gt; set variable &amp;#39;save_method$&amp;#39; to &amp;#34;id&amp;#34;
	###&amp;gt;&amp;gt;
	###&amp;gt;&amp;gt; Sounds are saved as .wav files,
	###&amp;gt;&amp;gt; other object types (TextGrids, Spectrum, etc.) are saved
	###&amp;gt;&amp;gt; with their own extension type (.TextGrid, .Spectrum).
	###&amp;gt;&amp;gt;
	###&amp;gt;&amp;gt; Default: the script will overwrite pre-existing files.
	###&amp;gt;&amp;gt; Set variable &amp;#39;overwrite$&amp;#39; to &amp;#34;no&amp;#34; if you want Praat
	###&amp;gt;&amp;gt; to throw an error instead.



################################################################################
### Variables you will definitely need to customize:
################################################################################

### Where should the selected objects be saved?

dir_out$ = &amp;#34;C:\Users\hanbos\mysounds&amp;#34;

### Should Praat overwrite pre-existing files?

overwrite$ = &amp;#34;yes&amp;#34;
#overwrite$ = &amp;#34;no&amp;#34;

### Do you want to save each object by its object name or by its id number?
### If object name, then use &amp;#34;name&amp;#34; (e.g., &amp;#34;sentence1.wav&amp;#34;).
### If object id number, then use &amp;#34;id&amp;#34; (e.g., &amp;#34;42.wav&amp;#34;).

save_method$ = &amp;#34;name&amp;#34;
#save_method$ = &amp;#34;id&amp;#34;





################################################################################
### Before we start, let&amp;#39;s check whether you&amp;#39;ve entered sensible
### input for the variables above...
################################################################################

### Let&amp;#39;s check if the output directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(dir_out$,1)=&amp;#34;/&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
elsif right$(dir_out$,1)=&amp;#34;\&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the output folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_out$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_out$&amp;#39; was not found
	exit Your directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif





################################################################################
################################################################################
#################################    SCRIPT    #################################
################################################################################
################################################################################

### Make sure you&amp;#39;ve selected the objects you&amp;#39;d like to save in
### the Praat object window. If nothing is selected, the script exits.

nSelected = numberOfSelected()
if nSelected = 0
	exit No objects selected.
endif

### Store the object id numbers in an array

for thisObject to nSelected
	objectArray [&amp;#39;thisObject&amp;#39;] = selected(&amp;#39;thisObject&amp;#39;)
endfor

### Loop through this array and for each id number
### select the corresponding object and save it.

for thisArrayNumber to nSelected
	objectId = objectArray [&amp;#39;thisArrayNumber&amp;#39;]
	select &amp;#39;objectId&amp;#39;
	type$ = extractWord$(selected$(), &amp;#34;&amp;#34;)
	name$ = extractLine$(selected$(), &amp;#34; &amp;#34;)
	
	if save_method$ = &amp;#34;name&amp;#34;
		if type$ = &amp;#34;Sound&amp;#34;
			does_file_exist = fileReadable(&amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.wav&amp;#34;)
			if does_file_exist = 1
				if overwrite$ = &amp;#34;no&amp;#34;
					exit The file &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.wav&amp;#39; already exists! If you wish to overwrite, set the variable overwrite$ to &amp;#34;yes&amp;#34;.
				endif
			endif
			Write to WAV file... &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.wav
		else
			does_file_exist = fileReadable(&amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.&amp;#39;type$&amp;#39;&amp;#34;)
			if does_file_exist = 1
				if overwrite$ = &amp;#34;no&amp;#34;
					exit The file &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.&amp;#39;type$&amp;#39; already exists! If you wish to overwrite, set the variable overwrite$ to &amp;#34;yes&amp;#34;.
				endif
			endif
			Write to text file... &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;.&amp;#39;type$&amp;#39;
		endif
	elsif save_method$ = &amp;#34;id&amp;#34;
		if type$ = &amp;#34;Sound&amp;#34;
			does_file_exist = fileReadable(&amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;objectId$&amp;#39;.wav&amp;#34;)
			if does_file_exist = 1
				if overwrite$ = &amp;#34;no&amp;#34;
					exit The file &amp;#39;dir_out$&amp;#39;\&amp;#39;objectId$&amp;#39;.wav&amp;#39; already exists! If you wish to overwrite, set the variable overwrite$ to &amp;#34;yes&amp;#34;.
				endif
			endif
			Write to WAV file... &amp;#39;dir_out$&amp;#39;\&amp;#39;objectId&amp;#39;.wav
		else
			does_file_exist = fileReadable(&amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;objectId$&amp;#39;.&amp;#39;type$&amp;#39;&amp;#34;)
			if does_file_exist = 1
				if overwrite$ = &amp;#34;no&amp;#34;
					exit The file &amp;#39;dir_out$&amp;#39;\&amp;#39;objectId$&amp;#39;.&amp;#39;type$&amp;#39; already exists! If you wish to overwrite, set the variable overwrite$ to &amp;#34;yes&amp;#34;.
				endif
			endif
			Write to text file... &amp;#39;dir_out$&amp;#39;\&amp;#39;objectId&amp;#39;.&amp;#39;type$&amp;#39;
		endif
	endif
endfor

### Now set the selection back to what it was before running this script.

for current to nSelected
	objectId = objectArray [&amp;#39;current&amp;#39;]
	if current = 1
		select &amp;#39;objectId&amp;#39;
	else
		plus &amp;#39;objectId&amp;#39;
	endif
endfor

################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Annotate</title>
      <link>https://hrbosker.github.io/resources/scripts/annotate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/annotate/</guid>
      <description>&lt;p&gt;This script streamlines an annotation workflow: it presents a TextGrid for manual annotation to the user, you perform some changes, and when you click Next, it automatically saves the changes and presents the next TextGrid, and so on. This is particularly useful for when you have forced aligned TextGrids (e.g., from &lt;a href=&#34;https://hrbosker.github.io/resources/other-resources/#videoaudio-editing&#34;&gt;WebMAUS&lt;/a&gt; or &lt;a href=&#34;https://hrbosker.github.io/resources/other-resources/#videoaudio-editing&#34;&gt;EasyAlign&lt;/a&gt;) that you&amp;rsquo;d like to manually evaluate and edit.&lt;/p&gt;
&lt;p&gt;Moreover, the script keeps track of who annotated what, can continue where you left off yesterday, allows users to enter comments about their annotations, and blinds file names to avoid human annotation biases. The script can be updated to present new empty TextGrids (instead of any pre-existing ones, in case you only have .wav files) or to automatically perform changes to TextGrid tiers/intervals before presenting them for manual annotation.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../annotate.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@ru.nl
### Date: 30 June 2022, run in Praat 6.2.12 on Windows 10
### License: CC BY-NC 4.0
################################################################################

	###&amp;gt;&amp;gt; This script reads a directory containing sound files with pre-existing TextGrids,
	###&amp;gt;&amp;gt;	for instance resulting from a forced aligner (e.g., WebMAUS or EasyAlign).
	###&amp;gt;&amp;gt;	IMPORTANT: Every Sound should have a pre-existing TextGrid file **with the same name**!
	###&amp;gt;&amp;gt;	It opens every Sound + Textgrid combination, presents it to the user for editing,
	###&amp;gt;&amp;gt;	allows the user to enter comments about the annotations, and then saves the
	###&amp;gt;&amp;gt;	edited TextGrid with &amp;#34;_edited&amp;#34; suffix in the subfolder &amp;#39;edited_textgrids&amp;#39;.
	###&amp;gt;&amp;gt;	User comments are tracked in the file &amp;#39;annotation_log.txt&amp;#39; in the same subfolder.
	###&amp;gt;&amp;gt;	
	###&amp;gt;&amp;gt;	&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; If you **do not** yet have pre-existing TextGrids (i.e., only sound files),	&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
	###&amp;gt;&amp;gt;	&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; you can adjust the script to read all .wav files, create new empty TextGrids,	&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
	###&amp;gt;&amp;gt;	&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; and present those for editing and saving...									&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
	###&amp;gt;&amp;gt;	&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; See the line with &amp;#34;CREATE EMPTY TEXTGRIDS&amp;#34;									&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
	###&amp;gt;&amp;gt;
	###&amp;gt;&amp;gt; This script can be run by multiple users simultaneously, for instance when
	###&amp;gt;&amp;gt;   multiple annotators are working on the same shared folder. It keeps track
	###&amp;gt;&amp;gt;   of what files have already been edited: it only presents TextGrids for editing
	###&amp;gt;&amp;gt;   that do not yet have an &amp;#34;_edited&amp;#34; version pre-existing in the subfolder.
	###&amp;gt;&amp;gt;   This also means that users can close the script or Praat at anytime
	###&amp;gt;&amp;gt;   without losing data. Then, next time someone runs the script, it will
	###&amp;gt;&amp;gt;   start with the files that are &amp;#39;left over&amp;#39; from the previous run.
	###&amp;gt;&amp;gt;	NOTE: This checking of which files already exist can slow the script down
	###&amp;gt;&amp;gt;	when working with folders with &amp;gt;5000 files...
	###&amp;gt;&amp;gt;
	###&amp;gt;&amp;gt; At present, the script **only** presents pre-existing tiers and intervals
	###&amp;gt;&amp;gt;   for editing (e.g., adding boundaries, dragging boundaries around, etc.).
	###&amp;gt;&amp;gt;   This script can be augmented by automatically adding tiers or intervals
	###&amp;gt;&amp;gt;   before the TextGrid is presented for editing, so users can annotate
	###&amp;gt;&amp;gt;   new tiers/intervals. See the line with &amp;#34;ADD/REMOVE TIERS HERE&amp;#34;.

################################################################################
### Variables you will definitely need to customize:
################################################################################

### Where can the Sound and TextGrid files be found?

dir_in$ = &amp;#34;C:\Users\hanbos\mysounds&amp;#34;

### Do you want to use &amp;#39;blinded&amp;#39; objects in Praat to avoid human biases in annotation?
### Default value: &amp;#34;yes&amp;#34;
### Change to &amp;#34;no&amp;#34; if you want to use original object names.

blinded$ = &amp;#34;yes&amp;#34;





################################################################################
### Before we start, let&amp;#39;s check whether you&amp;#39;ve entered sensible
### input for the variables above...
################################################################################

### Let&amp;#39;s check if the input directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(dir_in$,1)=&amp;#34;/&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
elsif right$(dir_in$,1)=&amp;#34;\&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_in$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_in$&amp;#39; was not found
	exit Your directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif

## Let&amp;#39;s also check whether a subfolder with edited TextGrids already exists,
## for instance when the script has been run and exited before.

temp_filename$ = dir_in$ + &amp;#34;/edited_textgrids/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the subfolder exists&amp;#34;

### Can the file be found?

subfolderfile_exists_yesno = fileReadable(temp_filename$)

if subfolderfile_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the subfolder already exists.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if it didn&amp;#39;t yet exist, let&amp;#39;s create the subfolder
	createFolder: &amp;#34;&amp;#39;dir_in$&amp;#39;/edited_textgrids&amp;#34;
endif





################################################################################
################################################################################
#################################    SCRIPT    #################################
################################################################################
################################################################################

## Let&amp;#39;s keep track of who annotated which file. This can be helpful when
## multiple annotators run the same script on the same shared folder.

beginPause: &amp;#34;Please enter your name:&amp;#34;
	text: &amp;#34;annotator&amp;#34;, &amp;#34;&amp;#34;
clicked = endPause: &amp;#34;Next&amp;#34;, 1

## Now we create a list of TextGrid files in the input directory:

Create Strings as file list: &amp;#34;list_of_files&amp;#34;, &amp;#34;&amp;#39;dir_in$&amp;#39;/*.TextGrid&amp;#34;

	#######################################################################################
	## CREATE EMPTY TEXTGRIDS
	########################
	## If you do not yet have pre-existing TextGrids (but a folder with only sound files instead),
	## you can read the sound files in the directory and create empty TextGrids for the user
	## to edit.
	## Adjust this script as follows:
	## - Change *.TextGrid to *.wav in the line above.
	## - Change *.TextGrid to *.wav in the line below starting with &amp;#34;extposition$&amp;#34;
	## - Replace this line: Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;name$&amp;#39;.TextGrid
	##		with this line: To TextGrid: &amp;#34;manual&amp;#34;, &amp;#34;&amp;#34;
	#######################################################################################

nfiles = Get number of strings
if nfiles = 0
	exit The directory &amp;#39;dir_in$&amp;#39; does not contain any TextGrid files.
endif

## By randomizing this file list, it allows for multiple users to simultanously work
## on the same folder without overwriting previous annotations. It also reduces the risk
## of human biases in annotations (e.g., annotator fatigue affecting one condition more
## than another condition).

Randomize

## Now we&amp;#39;ll loop through the list and present individual files...

for i from 1 to &amp;#39;nfiles&amp;#39;
	select Strings list_of_files
	
	fileplusext$ = Get string... &amp;#39;i&amp;#39;
	extposition = index(fileplusext$, &amp;#34;.TextGrid&amp;#34;)
	name$ = left$(fileplusext$, (&amp;#39;extposition&amp;#39;-1))

	outname$ = &amp;#34;&amp;#39;name$&amp;#39;_edited&amp;#34;
	fulloutname$ = &amp;#34;&amp;#39;dir_in$&amp;#39;/edited_textgrids/&amp;#39;outname$&amp;#39;.TextGrid&amp;#34;

	## Let&amp;#39;s check if an &amp;#34;_edited&amp;#34; version already exists.
	## The script only presents those files for editing that do not yet have been edited before.
	
	editedfile_exists_yesno = fileReadable(fulloutname$)
	if editedfile_exists_yesno
		do_nothing = 1
	else
		Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;name$&amp;#39;.wav
		if blinded$ = &amp;#34;yes&amp;#34;
			Rename... current_Sound
		endif
		sound_name$ = selected$(&amp;#34;Sound&amp;#34;)
		## If a filename contains spaces, Praat replaces these spaces with underscores.
		## Example: &amp;#34;file number 1.wav&amp;#34; in a given folder becomes
		##			&amp;#34;file_number_1.wav&amp;#34; in the Praat object window.
		## Therefore, it is important **not** to use a filename variable (here: &amp;#39;name$&amp;#39;)
		## in &amp;#39;selecting commands&amp;#39; in Praat, like &amp;#39;select&amp;#39; and &amp;#39;plus&amp;#39;!
		## Better still: do not use spaces in filenames!
		
		Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;name$&amp;#39;.TextGrid
		if blinded$ = &amp;#34;yes&amp;#34;
			Rename... current_TextGrid
		endif
		tg_name$ = selected$(&amp;#34;TextGrid&amp;#34;)

		#######################################################################################
		## ADD/REMOVE TIERS HERE
		########################
		## This is where we you could adjust the script to automatically add/remove tiers
		## and/or automatically adjust intervals (setting them to the nearest zero crossings?).
		## Duplicating tiers can be helpful when you want to view original vs. manually edited
		## tiers below/above each other in one and the same edited TextGrid.
		## Example:
		## &amp;gt; Duplicate tier... 1 1 newtier
		## [ARGUMENTS: position_of_tier_to_duplicate position_for_new_tier name_of_new_tier]
		#######################################################################################

		plus Sound &amp;#39;sound_name$&amp;#39;
		Edit

		beginPause: &amp;#34;Please check and edit this TextGrid.&amp;#34;
			comment: &amp;#34;Please check and edit the annotations.&amp;#34;
			text: &amp;#34;Comments&amp;#34;, &amp;#34;&amp;#34;
		clicked = endPause: &amp;#34;Next&amp;#34;, 1
		
		editor TextGrid &amp;#39;tg_name$&amp;#39;
			Close
		endeditor

		select TextGrid &amp;#39;tg_name$&amp;#39;
		Write to text file... &amp;#39;fulloutname$&amp;#39;
		plus Sound &amp;#39;sound_name$&amp;#39;
		Remove

		appendFileLine: &amp;#34;&amp;#39;dir_in$&amp;#39;/edited_textgrids/annotation_log.txt&amp;#34;, annotator$, tab$, name$, tab$, comments$
	endif
endfor

select Strings list_of_files
Remove

################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Batch processing</title>
      <link>https://hrbosker.github.io/resources/scripts/batch-processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/batch-processing/</guid>
      <description>&lt;p&gt;This script is an in-house template / starting point for batch processing multiple files. Adapt it to your own needs to apply a particular function to multiple files or multiple time intervals within each file.&lt;/p&gt;
&lt;p&gt;In its current form, the script reads each .wav file &lt;em&gt;plus&lt;/em&gt; accompanying TextGrid in a given input directory, extracts all non-empty intervals individually, and then loops over those to find the ones labelled &amp;ldquo;vowel&amp;rdquo;. It then allows the user to apply a particular function to those intervals (such as &lt;code&gt;Scale intensity: 65&lt;/code&gt;), after which it concatenates the individual intervals back together, and saves the output in an output directory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In its current form, the script does not run any function on its input. It really only serves as a starting point, including snippets of code we regularly use and now do not need to look up every time we want to do batch processing in Praat.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../batch-processing.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@ru.nl
### Date: 6 July 2022, run in Praat 6.2.12 on Windows 10
### License: CC BY-NC 4.0
################################################################################


	###&amp;gt;&amp;gt; This script is a starting point for batch processing a set of files.
	###&amp;gt;&amp;gt;	The script basically reads files in an input directory and runs a
	###&amp;gt;&amp;gt;	a to-be-defined function [see &amp;#39;Perform your function here&amp;#39; below]
	###&amp;gt;&amp;gt;	and writes the output to an output directory . This saves me having
	###&amp;gt;&amp;gt;	to look up how to create a file list, how to loop over files, etc.
	###&amp;gt;&amp;gt;	
	###&amp;gt;&amp;gt; Since this was basically intended for in-house use, I&amp;#39;ve added in bits
	###&amp;gt;&amp;gt;	and pieces that I find useful to have ready-to-go, such as:
	###&amp;gt;&amp;gt;	&amp;#39;beginPause&amp;#39; for manually specifying variables.

################################################################################
### Variables you will definitely need to customize:
################################################################################

### Where can the files be found?

dir_in$ = &amp;#34;C:\Users\hanbos\mysounds&amp;#34;

### Where should the output files be saved?

dir_out$ = &amp;#34;C:\Users\hanbos\mysounds\output&amp;#34;





################################################################################
### Let&amp;#39;s check whether the directories specified above exist...
################################################################################

### Let&amp;#39;s check if the input directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(dir_in$,1)=&amp;#34;/&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
elsif right$(dir_in$,1)=&amp;#34;\&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_in$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_in$&amp;#39; was not found
	exit Your input directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif

## Now re-do this for the output directory:

if right$(dir_out$,1)=&amp;#34;/&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
elsif right$(dir_out$,1)=&amp;#34;\&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_out$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_out$&amp;#39; was not found
	exit Your output directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif





###########################################################################
##	FORM TO MANUALLY SPECIFY VARIABLES
###########################################################################
#beginPause: &amp;#34;Enter settings&amp;#34;
#	comment: &amp;#34;Provide instructions here&amp;#34;
#	real: &amp;#34;minPitch&amp;#34;, 70
#	real: &amp;#34;maxPitch&amp;#34;, 250
#	choice: &amp;#34;method&amp;#34;, 1
#	   option: &amp;#34;Flip F0 contour&amp;#34;
#	   option: &amp;#34;Expand/Contract F0 contour&amp;#34;
#	   option: &amp;#34;Flatten F0 contour&amp;#34;
#clicked = endPause (&amp;#34;Cancel&amp;#34;, &amp;#34;OK&amp;#34;, 2)
###########################################################################
###########################################################################





## Let&amp;#39;s create a list of all the files in the input directory.

Create Strings as file list: &amp;#34;list_of_files&amp;#34;, &amp;#34;&amp;#39;dir_in$&amp;#39;/*.wav&amp;#34;

nfiles = Get number of strings
if nfiles = 0
	exit The directory &amp;#39;dir_in$&amp;#39; does not contain any .wav files.
endif

## Now we&amp;#39;ll loop through the list...

for i from 1 to &amp;#39;nfiles&amp;#39;
	select Strings list_of_files
	
	fileplusext$ = Get string... &amp;#39;i&amp;#39;
	extposition = index(fileplusext$, &amp;#34;.wav&amp;#34;)
	name$ = left$(fileplusext$, (&amp;#39;extposition&amp;#39;-1))

	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;name$&amp;#39;.wav
	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;name$&amp;#39;.TextGrid
	plus Sound &amp;#39;name$&amp;#39;
	Extract non-empty intervals... 1 no
	
	nSelected = numberOfSelected()

	## Assign an object number to each object (e.g., 1-5),
	## and save the id numbers of each object to an array.

	for thisObject to nSelected
		objectArray [&amp;#39;thisObject&amp;#39;] = selected(&amp;#39;thisObject&amp;#39;)
	endfor

	for j to nSelected
		curr_objectId = objectArray [&amp;#39;j&amp;#39;]
		select &amp;#39;curr_objectId&amp;#39;
		curr_objectName$ = selected$(&amp;#34;Sound&amp;#34;)
		
		if curr_objectName$ = &amp;#34;vowel&amp;#34;

			########################################################################
			# Perform your function here!
			#	Example: Scale intensity... 65
			########################################################################

		endif
	endfor

	for j from 1 to nSelected
		curr_objectId = objectArray [&amp;#39;j&amp;#39;]
		if j = 1
			select &amp;#39;curr_objectId&amp;#39;
		else
			plus &amp;#39;curr_objectId&amp;#39;
		endif
	endfor
	Concatenate recoverably

	select Sound chain
	Write to WAV file... &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;_manipulated.wav
	select TextGrid chain
	Write to text file... &amp;#39;dir_out$&amp;#39;\&amp;#39;name$&amp;#39;_manipulated.TextGrid

	## Cleaning up...
	for j from 1 to nSelected
		curr_objectId = objectArray [&amp;#39;j&amp;#39;]
		if j = 1
			select &amp;#39;curr_objectId&amp;#39;
		else
			plus &amp;#39;curr_objectId&amp;#39;
		endif
	endfor
	plus Sound chain
	plus TextGrid chain
	plus Sound &amp;#39;name$&amp;#39;
	plus TextGrid &amp;#39;name$&amp;#39;
	Remove

endfor

select Strings list_of_files
Remove

################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Move to zero-crossings</title>
      <link>https://hrbosker.github.io/resources/scripts/move-to-zero-crossings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/move-to-zero-crossings/</guid>
      <description>&lt;p&gt;This script automatically moves all boundaries in a given tier in a TextGrid file to zero-crossings, which is important for extracting sound intervals. Specifically, it adds a tier &amp;rsquo;to0x&amp;rsquo; at the top of the TextGrid that is identical to a given input tier, except that all boundaries are at zero-crossings.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../move-to-zero-crossings.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@ru.nl
### Date: 22 July 2022, run in Praat 6.2.12 on Windows 10
### License: CC BY-NC 4.0
################################################################################

	###&amp;gt;&amp;gt; This script takes a single .wav and matching .TextGrid file as input
	###&amp;gt;&amp;gt;   and moves all boundaries in one particular tier to zero-crossings.

	###&amp;gt;&amp;gt;   Specifically, it *adds* a new &amp;#39;to0x&amp;#39; tier at the top of the TextGrid
	###&amp;gt;&amp;gt;   that is identical to a given tier except that all boundaries are
	###&amp;gt;&amp;gt;   at zero-crossings. The old TextGrid is then overwritten with the
	###&amp;gt;&amp;gt;   new extended TextGrid, but no information is lost (only added).

	###&amp;gt;&amp;gt;   This script works best if the script also subtracts the mean from
	###&amp;gt;&amp;gt;   the audio signal, and overwrites the original audio:
	###&amp;gt;&amp;gt;	&amp;#39;method&amp;#39; option 1 (default).

	###&amp;gt;&amp;gt;	If you need to move the boundaries for more than one TextGrid file,
	###&amp;gt;&amp;gt;	you can merge this script with &amp;#39;batch-processing.praat&amp;#39;,
	###&amp;gt;&amp;gt;	see: https://hrbosker.github.io/resources/scripts/batch-processing/


################################################################################
### Form to enter variables
################################################################################
beginPause: &amp;#34;Enter settings&amp;#34;
	comment: &amp;#34;Provide the directory of the sound and TextGrid file (no slash at end of string)&amp;#34;
	text: &amp;#34;directory&amp;#34;, &amp;#34;C:/Users/hanbos/mysounds&amp;#34;
	comment: &amp;#34;Provide the name of the sound file&amp;#34;
	comment: &amp;#34;(should be identical to TextGrid name)&amp;#34;
	comment: &amp;#34;NOTE: do NOT include any extension (no .wav)&amp;#34;
	text: &amp;#34;filename&amp;#34;, &amp;#34;syll1&amp;#34;
	comment: &amp;#34;Provide the interval tier number (typically 1)&amp;#34;
	real: &amp;#34;tierNumber&amp;#34;, 1
	choice: &amp;#34;method&amp;#34;, 1
	   option: &amp;#34;Subtract mean and overwrite audio file&amp;#34;
	   option: &amp;#34;Do not subtract mean&amp;#34;
clicked = endPause (&amp;#34;Cancel&amp;#34;, &amp;#34;OK&amp;#34;, 2)



################################################################################
### Before we start, let&amp;#39;s check whether you&amp;#39;ve entered sensible
### input for the variables above...
################################################################################

### Let&amp;#39;s check if the directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(directory$,1)=&amp;#34;/&amp;#34;
	directory$ = left$(directory$,length(directory$)-1)
elsif right$(directory$,1)=&amp;#34;\&amp;#34;
	directory$ = left$(directory$,length(directory$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = directory$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$

	## Let&amp;#39;s also check whether the specified wav and TextGrid filenames exist
	## inside this particular directory.

	filepath$ = directory$ + &amp;#34;/&amp;#34; + filename$ + &amp;#34;.wav&amp;#34;
	wavFileExists = fileReadable(filepath$)

	if wavFileExists = 0
		# if the wav file does not exist
		printline Could not find &amp;#39;filename$&amp;#39;.wav in the folder &amp;#39;directory$&amp;#39;
		exit Could not find &amp;#39;filename$&amp;#39;.wav in the folder &amp;#39;directory$&amp;#39;. Check spelling.
	endif

	filepath$ = directory$ + &amp;#34;/&amp;#34; + filename$ + &amp;#34;.TextGrid&amp;#34;
	tgFileExists = fileReadable(filepath$)

	if tgFileExists = 0
		# if the TextGrid file does not exist
		printline Could not find &amp;#39;filename$&amp;#39;.TextGrid in the folder &amp;#39;directory$&amp;#39;
		exit Could not find &amp;#39;filename$&amp;#39;.TextGrid in the folder &amp;#39;directory$&amp;#39;. Check spelling.
	endif
else
	# if the temporary file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;directory$&amp;#39; was not found
	exit Your directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif



################################################################################
################################################################################
#################################    SCRIPT    #################################
################################################################################
################################################################################

Read from file... &amp;#39;directory$&amp;#39;\&amp;#39;filename$&amp;#39;.wav
if method = 1
	Subtract mean
	Write to WAV file... &amp;#39;directory$&amp;#39;\&amp;#39;filename$&amp;#39;.wav
endif
Read from file... &amp;#39;directory$&amp;#39;\&amp;#39;filename$&amp;#39;.TextGrid
nInts = Get number of intervals... &amp;#39;tierNumber&amp;#39;
Insert interval tier... 1 to0x

for i to (&amp;#39;nInts&amp;#39;-1)
	select TextGrid &amp;#39;filename$&amp;#39;
	intEnd = Get end point... (&amp;#39;tierNumber&amp;#39;+1) &amp;#39;i&amp;#39;
	intLab$ = Get label of interval... (&amp;#39;tierNumber&amp;#39;+1) &amp;#39;i&amp;#39;
	select Sound &amp;#39;filename$&amp;#39;
	zxEnd = Get nearest zero crossing... 1 &amp;#39;intEnd&amp;#39;
	select TextGrid &amp;#39;filename$&amp;#39;
	Insert boundary... 1 zxEnd
	Set interval text... 1 &amp;#39;i&amp;#39; &amp;#39;intLab$&amp;#39;
endfor
intLab$ = Get label of interval... (&amp;#39;tierNumber&amp;#39;+1) &amp;#39;nInts&amp;#39;
Set interval text... 1 &amp;#39;nInts&amp;#39; &amp;#39;intLab$&amp;#39;

Write to text file... &amp;#39;directory$&amp;#39;\&amp;#39;filename$&amp;#39;.TextGrid
Remove
select Sound &amp;#39;filename$&amp;#39;
Remove

################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Manipulate ITD/IID</title>
      <link>https://hrbosker.github.io/resources/scripts/manipulate-itd-iid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/manipulate-itd-iid/</guid>
      <description>&lt;p&gt;This script allows you to create a &amp;lsquo;virtual auditory reality&amp;rsquo; by implementing interaural time differences (ITD) and interaural intensity differences (IID) for two sounds. Thus we simulate naturalistic perception of two fully lateralized sound sources.&lt;/p&gt;
&lt;p&gt;When you want to play two talkers as coming from opposite sides (talker1 from the left, talker2 from the right), you could simply present the talkers in different channels of a stereo sound file. This way, when your listeners use headphones, talker1 is the only signal played in the left ear and talker2 is the only signal played in the right ear. This design, however, does not reflect naturalistic acoustic environments where the speech of a given talker typically reaches &lt;em&gt;both ears&lt;/em&gt;. Moreover, such a simplistic 2-channel design also completely avoids any energetic masking from one talker onto the next.&lt;/p&gt;
&lt;p&gt;In order to simulate more naturalistic multitalker environments, one can present the same sound to both ears, but with a slight delay (interaural time difference; ITD) and at a slightly lower intensity in one ear vs. the other (interaural intensity difference; IID). This way we simulate the shadowing effect of the listener&amp;rsquo;s head, maintaining naturalistic energetic masking.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&#34;https://hrbosker.github.io/demos/cocktail-party/&#34;&gt;this demo&lt;/a&gt; for some examples and further details.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../manipulate-ITD-IID.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@donders.ru.nl
### Date: 19 July 2023, run in Praat 6.3.08 on Windows 10
### License: CC BY-NC 4.0
################################################################################


    ###&amp;gt;&amp;gt; This script takes two input sounds and applies interaural time differences (ITD)
    ###&amp;gt;&amp;gt;	and interaural intensity differences (IID) in order to induce &amp;#39;virtual&amp;#39; spatial
    ###&amp;gt;&amp;gt;	segregation of the two sosunds. This makes one sound be perceived as coming
    ###&amp;gt;&amp;gt;	from the left and the other sound as coming from the right, despite the fact
    ###&amp;gt;&amp;gt;   that both sounds are physically present in either channel. Use headphones
    ###&amp;gt;&amp;gt;   (i.e., not speakers) to best experience this spatial segregation. And remember:
    ###&amp;gt;&amp;gt;   wear the headphones appropriately (i.e., with L on your left ear, R on the right)

    ###&amp;gt;&amp;gt; In its current form, the script simply reads in two pre-defined mono sounds
    ###&amp;gt;&amp;gt;   and gives as output two stereo wav files: one wav file with sound1 perceived
    ###&amp;gt;&amp;gt;   as coming from the left and another with sound1 perceived as coming from the right.
    ###&amp;gt;&amp;gt;   Combine this script with the batch-processing.praat script to process
    ###&amp;gt;&amp;gt;   a larger number of files.

    ###&amp;gt;&amp;gt; Remember: the two sounds should be mono sound files (1-channel) with
    ###&amp;gt;&amp;gt;   the same sampling frequency.

################################################################################
### Variables you will definitely need to customize:
################################################################################

### Where can the files be found?

dir_in$ = &amp;#34;C:\Users\hanbos\Desktop\mysounds&amp;#34;

### Where should the output files be saved?

dir_out$ = &amp;#34;C:\Users\hanbos\Desktop\mysounds&amp;#34;





################################################################################
### Let&amp;#39;s check whether the directories specified above exist...
################################################################################

### Let&amp;#39;s check if the input directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(dir_in$,1)=&amp;#34;/&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
elsif right$(dir_in$,1)=&amp;#34;\&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_in$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_in$&amp;#39; was not found
	exit Your input directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif

## Now re-do this for the output directory:

if right$(dir_out$,1)=&amp;#34;/&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
elsif right$(dir_out$,1)=&amp;#34;\&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_out$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete that temp txt file.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_out$&amp;#39; was not found
	exit Your output directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif





################################################################################
################################################################################
#################################    SCRIPT    #################################
################################################################################
################################################################################

## Enter the filenames of the two sounds in the variables below.
## Remember to include the file extension (e.g., &amp;#34;firstsound.wav&amp;#34;)
## but the filenames themselves should not contain any [.] character.

soundfile1$ = &amp;#34;firstsound.wav&amp;#34;
extposition = index(soundfile1$, &amp;#34;.&amp;#34;)
soundname1$ = left$(soundfile1$, (&amp;#39;extposition&amp;#39;-1))

Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;soundfile1$&amp;#39;
Rename... original_s1
Convert to mono
Rename... soundone
fs_1 = Get sampling frequency
int_1 = Get intensity (dB)

soundfile2$ = &amp;#34;secondsound.wav&amp;#34;
extposition = index(soundfile2$, &amp;#34;.&amp;#34;)
soundname2$ = left$(soundfile2$, (&amp;#39;extposition&amp;#39;-1))

Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;soundfile2$&amp;#39;
Rename... original_s2
Convert to mono
Rename... soundtwo
fs_2 = Get sampling frequency
int_2 = Get intensity (dB)

if fs_1 &amp;lt;&amp;gt; fs_2
	# if the two files have different sampling frequencies
	printline &amp;#39;soundfile1$&amp;#39; has a sampling frequency of &amp;#39;fs_1&amp;#39; Hz.
    printline &amp;#39;soundfile2$&amp;#39; has a sampling frequency of &amp;#39;fs_2&amp;#39; Hz.
	exit The two files have different sampling frequencies. Resample to match the sampling frequencies.
endif





## The ITD implemented here is 0.6 ms = 600 microseconds.
## This ITD simulates fully lateralized sound sources (Hartmann, 1999)
itd = 0.0006
Create Sound from formula: &amp;#34;itd&amp;#34;, 1, 0, 0.0006, &amp;#39;fs_1&amp;#39;, &amp;#34;0&amp;#34;

## The ITD silence should precede the other two sounds in the Objects window
select Sound soundone
Copy... sound1
select Sound soundone
Remove
select Sound soundtwo
Copy... sound2
select Sound soundtwo
Remove




## The IID implemented here is -6 dB, simulating fully lateralized sound sources (Hartmann, 1999)

## Create the left channel, with sound1 appearing as coming from the left
select Sound itd
plus Sound sound2
Concatenate
Scale intensity... (&amp;#39;int_2&amp;#39;-6)
Formula... self + Sound_sound1[]
Rename... channel_L

## Create the right channel, with sound2 appearing as coming from the right
select Sound itd
plus Sound sound1
Concatenate
Scale intensity... (&amp;#39;int_1&amp;#39;-6)
Formula... self + Sound_sound2[]
Rename... channel_R

select Sound channel_L
plus Sound channel_R
Combine to stereo
Rename... L_s1_R_s2
Write to WAV file... &amp;#39;dir_in$&amp;#39;\L_&amp;#39;soundname1$&amp;#39;_R_&amp;#39;soundname2$&amp;#39;.wav
Remove

## And the opposite localization:

select Sound channel_R
Copy... channel_left
select Sound channel_L
Copy... channel_right
plus Sound channel_left
Combine to stereo
Rename... R_s1_L_s2
Write to WAV file... &amp;#39;dir_in$&amp;#39;\L_&amp;#39;soundname2$&amp;#39;_R_&amp;#39;soundname1$&amp;#39;.wav
Remove

## And clear up the mess
select Sound channel_L
plus Sound channel_R
plus Sound channel_left
plus Sound channel_right
plus Sound original_s1
plus Sound original_s2
plus Sound itd
plus Sound sound1
plus Sound sound2
Remove



################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Interpolate F0 continuum</title>
      <link>https://hrbosker.github.io/resources/scripts/interpolate-f0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/interpolate-f0/</guid>
      <description>&lt;p&gt;This script creates an F0 continuum for two segmentally matching words (e.g., &lt;em&gt;SUBject&lt;/em&gt; vs. &lt;em&gt;subJECT&lt;/em&gt;). First, it matches the two words in duration and then interpolates the F0 contour linearly in 11 steps (steps 1 and 11 being the original contours), controlling for intensity.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../interpolate-F0.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#____________________________________ HEADER __________________________________####
# date:         31.01.2023, run in Praat 6.2.12 on Windows 11
# author:       Ronny Bujok (adapted from Hans Rutger Bosker)
# email:        Ronny.Bujok@mpi.nl
# filename:     F0_stress continuum_interpolation.praat
# project:      Audiovisual Perception of Lexical Stress
# license:		CC BY-NC 4.0

####################################################################################################################
# This script takes recordings of segmentally identical, disyllabic minimal stress pairs with lexical stress on the first 
# (strong-weak; SW) or second (weak-strong; WS) syllable (e.g., VOORnaam vs. voorNAAM) and interpolates their F0-contours linearly. 
# The manipulated F0-contours are applied to the SW recording to create an F0-based lexical stress continuum.
# Duration and Intensity are set to mean, ambiguous values.
#
# This script requires minimal pairs to match in their name. Stress pattern in input files is denoted with &amp;#34;_sw&amp;#34; or &amp;#34;_ws&amp;#34; 
# (e.g., voornaam_sw.wav &amp;amp; voornaam_ws.wav). No other underscore characters are allowed.
# Textgrids for each recording are required, with boundaries at word onset, second syllable onset and word offset.
#
# Note that the parameters for pitch estimation are set to match a male voice. When working with a female voice,
# please adjust the arguments of the functions &amp;#34;Lengthen (overlap-add)&amp;#34; and &amp;#34;To Manipulation&amp;#34;.
####################################################################################################################


# Define input and output directory
input_directory$ = &amp;#34;C:\input folder&amp;#34;
output_directory$= &amp;#34;C:\output folder&amp;#34;

# create file list of all files with the ending &amp;#34;_sw.wav&amp;#34; (just sound files, one per minimal pair (sw))
Create Strings as file list... list &amp;#39;input_directory$&amp;#39;\*_sw.wav
n = Get number of strings

# _________________________________ CREATE FILELIST ____________________________________________________

# create list again because it removes itself after every iteration
for x from 1 to n
	Create Strings as file list... list &amp;#39;input_directory$&amp;#39;\*_sw.wav

# get only the word name without extension or stress identifier (sw or ws)
	select Strings list
	current_file$ = Get string... x
	idx = rindex (current_file$, &amp;#34;_&amp;#34;)
	word$ = left$(current_file$,idx-1)

#_____________________________________ DURATION ___________________________________________________________

# To interpolate F0 contours, recordings must be of equal length. So duration must be manipulated first. 

#---------------------------------- get values from SW word ---------------------------------------------
# open SW word and convert to mono
		wavfile_sw$ = &amp;#34;&amp;#39;word$&amp;#39;_sw&amp;#34;
		Read from file... &amp;#39;input_directory$&amp;#39;\&amp;#39;wavfile_sw$&amp;#39;.Textgrid
		Read from file... &amp;#39;input_directory$&amp;#39;\&amp;#39;wavfile_sw$&amp;#39;.wav
		Convert to mono
		Rename: &amp;#34;mono_sw&amp;#34;
		wav_sw_id = selected()
# select the mono file and the corresponding textgrid and extract all intervals
		selectObject: &amp;#34;TextGrid &amp;#39;wavfile_sw$&amp;#39;&amp;#34;
		plusObject: &amp;#34;Sound mono_sw&amp;#34;
		Extract all intervals: 1, &amp;#34;no&amp;#34;
# select the second interval (first syllable) and get the total duration and the intensity	
		select (wav_sw_id+2)  
		sw_dur1= Get total duration
		sw_int1= Get intensity (dB)
		Rename: &amp;#34;sw_1&amp;#34;
# select the third interval (second syllable) and get the total duration and the intensity		
		select (wav_sw_id+3)
		sw_dur2= Get total duration
		sw_int2= Get intensity (dB)
		Rename: &amp;#34;sw_2&amp;#34;

# select and rename the first and last interval (silences) for future reference, to concatenate the final audio
		select (wav_sw_id+1)
		Rename: &amp;#34;pre_silence_sw&amp;#34;
		select (wav_sw_id+4)
		Rename: &amp;#34;post_silence_sw&amp;#34;
		
#---------------------------------- get values from WS word -----------------------------------------

# open WS word and convert to mono		
		wavfile_ws$ = &amp;#34;&amp;#39;word$&amp;#39;_ws&amp;#34;
		Read from file... &amp;#39;input_directory$&amp;#39;\&amp;#39;wavfile_ws$&amp;#39;.Textgrid
		Read from file... &amp;#39;input_directory$&amp;#39;\&amp;#39;wavfile_ws$&amp;#39;.wav
		Convert to mono
		Rename: &amp;#34;mono_ws&amp;#34;
		wav_ws_id = selected()
# select the mono file and the corresponding textgrid and extract all intervals		
		selectObject: &amp;#34;TextGrid &amp;#39;wavfile_ws$&amp;#39;&amp;#34;
		plusObject: &amp;#34;Sound mono_ws&amp;#34;
		Extract all intervals: 1, &amp;#34;no&amp;#34;
# select the second interval (first syllable) and get the total duration and the intensity			
		select (wav_ws_id+2)
		ws_dur1= Get total duration
		ws_int1= Get intensity (dB)
		Rename: &amp;#34;ws_1&amp;#34;	
# select the third interval (second syllable) and get the total duration and the intensity		
		select (wav_ws_id+3)
		ws_dur2= Get total duration
		ws_int2= Get intensity (dB)
		Rename: &amp;#34;ws_2&amp;#34;	


#---------------------------------- Manipulate duration ------------------------------------------

# Set the duration of syllable 1 of the SW word to the average, ambiguous duration
		select Sound sw_1
		targetdur_1 = ((sw_dur1+ws_dur1)/2)
		Lengthen (overlap-add)... 75 250 (targetdur_1/sw_dur1)
		Rename: &amp;#34;sw_1_durmatched&amp;#34;			
# Set the duration of syllable 2 of the SW word to the average, ambiguous duration
        select Sound sw_2
		targetdur_2 = ((sw_dur2+ws_dur2)/2)
		Lengthen (overlap-add)... 75 250 (targetdur_2/sw_dur2)
		Rename: &amp;#34;sw_2_durmatched&amp;#34;	
		
# Set the duration of syllable 1 of the WS word to the average, ambiguous duration
        select Sound ws_1
		Lengthen (overlap-add)... 75 250 (targetdur_1/ws_dur1)
		Rename: &amp;#34;ws_1_durmatched&amp;#34;		
# Set the duration of syllable 2 of the WS word to the average, ambiguous duration
        select Sound ws_2
		Lengthen (overlap-add)... 75 250 (targetdur_2/ws_dur2)
		Rename: &amp;#34;ws_2_durmatched&amp;#34;
		


# Concatenate duration-manipulated SW word
		select Sound sw_1_durmatched
		plusObject: &amp;#34;Sound sw_2_durmatched&amp;#34;
		Concatenate recoverably
		select Sound chain
		Rename: &amp;#34;durmatched_sw&amp;#34;
# Concatenate duration-manipulated WS word
        select Sound ws_1_durmatched
		plusObject: &amp;#34;Sound ws_2_durmatched&amp;#34;
		Concatenate recoverably
		select Sound chain
		Rename: &amp;#34;durmatched_ws&amp;#34;
		
# save TextGrid with the boundary between the syllables. Necessary for intensity manipulation
		select TextGrid chain
		Rename: &amp;#34;syl_boundary&amp;#34;
		

		
#__________________________________________ F0 INTERPOLATION ________________________________________________

# Extract the pitch tiers
		select Sound durmatched_sw
		s1_dur = Get total duration
		To Manipulation... 0.01 50 300
		Extract pitch tier

		select Sound durmatched_ws
		s2_dur = Get total duration
		To Manipulation... 0.01 50 300
		Extract pitch tier

# create 10 ms time bins for interpolation
		timebinsize = 0.01
		nbins = floor(s1_dur/timebinsize)

		for currentbin from 1 to &amp;#39;nbins&amp;#39;
			currentbin_start = (currentbin*timebinsize)-timebinsize
			currentbin_end = (currentbin*timebinsize)
			currentbin_mid = (currentbin_start + currentbin_end)/2
			select PitchTier durmatched_sw
			currentbin_f0_s1 = Get value at time... currentbin_mid
			f0_bin_s1 [currentbin] = currentbin_f0_s1
			select PitchTier durmatched_ws
			currentbin_f0_s2 = Get value at time... currentbin_mid
			f0_bin_s2 [currentbin] = currentbin_f0_s2
		endfor

#define number of steps for interpolation
		nsteps = 11
		step_ratio = 1/(&amp;#39;nsteps&amp;#39;-1)
		# This means that...
		#	the stepsize is 10% of the difference between SW and WS;
		#	step 1 of the continuum is the original SW contour;
		#	step 11 of the continuum is the original WS contour. 
		

# interpolate the pitch tiers 
		for currentstep from 1 to &amp;#39;nsteps&amp;#39;
			select PitchTier durmatched_sw
			Copy... interpol_&amp;#39;currentstep&amp;#39;

			# first remove all original F0 points
			Remove points between... 0 &amp;#39;s1_dur&amp;#39;
			
			# now add a point for each time bin
			for currentbin from 1 to &amp;#39;nbins&amp;#39;
				currentbin_start = (currentbin*timebinsize)-timebinsize
				currentbin_end = (currentbin*timebinsize)
				currentbin_mid = (currentbin_start + currentbin_end)/2
				currentbin_f0_s1 = f0_bin_s1 [currentbin]
				currentbin_f0_s2 = f0_bin_s2 [currentbin]
				currentbin_f0_diff = currentbin_f0_s1 - currentbin_f0_s2
				currentbin_f0_ratio = currentbin_f0_diff * &amp;#39;step_ratio&amp;#39;
				currentbin_f0_interpol = currentbin_f0_s1 - (currentbin_f0_ratio * (&amp;#39;currentstep&amp;#39;-1))
				
				Add point... &amp;#39;currentbin_mid&amp;#39; &amp;#39;currentbin_f0_interpol&amp;#39;
			endfor
			
# select original audio (in this case SW recording) and replace the pitch contour
			select Manipulation durmatched_sw
			Copy... interpol_&amp;#39;currentstep&amp;#39;			
			plusObject: &amp;#34;PitchTier interpol_&amp;#39;currentstep&amp;#39;&amp;#34;
			Replace pitch tier
			minusObject: &amp;#34;PitchTier interpol_&amp;#39;currentstep&amp;#39;&amp;#34;
			Get resynthesis (overlap-add)
			
			interval_id = selected()

#__________________________________________ INTENSITY____________________________________________________

# extract each syllable again for intensity manipulation
			plusObject: &amp;#34;TextGrid syl_boundary&amp;#34;
			Extract all intervals: 1, &amp;#34;no&amp;#34;

# set (average) target intensity per syllable
            targetint_1 = ((sw_int1+ws_int1)/2) 
            targetint_2 = ((sw_int2+ws_int2)/2) 
			
# adjust the intensities to an average/ambigous value
			select (interval_id+1)
			Scale intensity... targetint_1
			Rename: &amp;#34;final_syl_1&amp;#34;
			
			select (interval_id+2)
			Scale intensity... targetint_2
			Rename: &amp;#34;final_syl_2&amp;#34;

#______________________________________ CONCATENATE &amp;amp; SAVE ______________________________________________

# copy final segment of the recording (silence post word offset), so Praat concatenates in the correct order
			select Sound post_silence_sw
			Copy... post_silence_sw_copy
# select remaining segments
			plusObject: &amp;#34;Sound pre_silence_sw&amp;#34;
			plusObject: &amp;#34;Sound final_syl_1&amp;#34;
			plusObject: &amp;#34;Sound final_syl_2&amp;#34;
			plusObject: &amp;#34;post_silence_sw_copy&amp;#34;
# concatenate
			Concatenate recoverably
			select Sound chain
			Rename: &amp;#34;&amp;#39;word$&amp;#39;_step_&amp;#39;currentstep&amp;#39;&amp;#34;
			Save as WAV file... &amp;#39;output_directory$&amp;#39;\&amp;#39;word$&amp;#39;_step_&amp;#39;currentstep&amp;#39;.wav
			select TextGrid chain
			Save as text file... &amp;#39;output_directory$&amp;#39;\&amp;#39;word$&amp;#39;_step_&amp;#39;currentstep&amp;#39;.TextGrid

		endfor
	
	select all
	Remove
	
endfor

################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Manipulate formants</title>
      <link>https://hrbosker.github.io/resources/scripts/manipulate-formants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://hrbosker.github.io/resources/scripts/manipulate-formants/</guid>
      <description>&lt;p&gt;This script gradually shifts a formant track (here: first formant, F1) to create a phonetic continuum from high-to-low (e.g., from &amp;ldquo;bet&amp;rdquo; to &amp;ldquo;bit&amp;rdquo;). It takes a list of word pairs as input, reads the first member, and applies the formant shift while controlling for intensity and f0.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;../manipulate-formants.praat&#34;&gt;download the script&lt;/a&gt; as a .praat file.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;################################################################################
### Hans Rutger Bosker, Radboud University
### HansRutger.Bosker@donders.ru.nl
### based on an earlier script created by Matthias Sjerps
### Date: 20 July 2023, run in Praat 6.3.08 on Windows 10
### License: CC BY-NC 4.0
################################################################################


	###&amp;gt;&amp;gt; This script takes pairs of items (e.g., bet and bit) from a directory
	###&amp;gt;&amp;gt;	that critically only differ in their F1 (&amp;#34;bet&amp;#34; has higher F1 than &amp;#34;bit&amp;#34;).
	###&amp;gt;&amp;gt;	The script then creates a phonetic continuum from high F1 (bet) to low F1 (bit)
	###&amp;gt;&amp;gt;	using Burg&amp;#39;s LPC method.
	
	###&amp;gt;&amp;gt; IMPORTANT: Please provide a list of word pairs in a .txt file in the
	###&amp;gt;&amp;gt;	input directory. This file should contain two tab-separated columns
	###&amp;gt;&amp;gt;	with the labels &amp;#34;word1&amp;#34; and &amp;#34;word2&amp;#34;. Then script then loops over the
	###&amp;gt;&amp;gt;	rows in this list of pairs. For example:
	
	###&amp;gt;&amp;gt;	word1	word2
	###&amp;gt;&amp;gt;	bet	bit
	###&amp;gt;&amp;gt;	get	git
	###&amp;gt;&amp;gt;	set	sit

	###&amp;gt;&amp;gt; IMPORTANT: Every individual sound file should already have an accompanying
	###&amp;gt;&amp;gt;	.TextGrid file containing one tier. This tier should have 3 intervals:
	###&amp;gt;&amp;gt;	1. The interval preceding the critical vowel
	###&amp;gt;&amp;gt;	2. The interval of the critical vowel
	###&amp;gt;&amp;gt;	3. The interval following the critical vowel

	###&amp;gt;&amp;gt; The script includes transplantation of the intensity contour of the original
	###&amp;gt;&amp;gt;	word1 to the manipulated output sound. The script can also set the
	###&amp;gt;&amp;gt;	f0 of the manipulated vowel to a fixed average value calculated
	###&amp;gt;&amp;gt;	across the two members of an item pair. This is done by setting
	###&amp;gt;&amp;gt;	the variable control_f0$ to the value &amp;#34;yes&amp;#34;.

	
################################################################################
### Variables you will definitely need to customize:
################################################################################

### Where can the files be found?

dir_in$ = &amp;#34;C:\Users\hanbos\Desktop\mysounds&amp;#34;

### Where should the output files be saved?

dir_out$ = &amp;#34;C:\Users\hanbos\Desktop\mysounds\continua&amp;#34;

### What is the name of the .txt file containing the list of word pairs?
### 	NOTE: Do **NOT** include the .txt extension; just the name!

table_name$ = &amp;#34;list_of_pairs&amp;#34;

### Next to the formant manipulations, do you also want to control the f0 and duration
### 	of the output sounds by setting them to the average value between the two words?

control_f0$ = &amp;#34;yes&amp;#34;

### Number of estimated formants (default: 5)
nformants = 5
### Provide the max. frequency for filtering (default for F1: 3000)
### 	Manipulations will be performed below this frequency only;
### 	the original signal is used above this frequency.
###		This helps to create natural-sounding (i.e., convincing) output speech.
filter = 3000
### Provide cutoff frequency for formant detection (default: 11000)
cutoff = 11000
### Provide the min and max pitch settings.
###		For female talker: 100 - 400
###		For male talker: 75 - 300
minpitch = 100
maxpitch = 400
### Define how many steps should be on your continua.
###		It helps if this value is an odd number so you have a &amp;#39;true&amp;#39; average
###		in the middle. Default is 11 because this means the steps go up/down
###		by 10% every time. This means that step 1 has the mean F1 of the original
###		high-F1 member (e.g., bet) and step 11 has the mean F1 of the original
###		low-F1 member (e.g., bit).
nSteps = 11
### Define your manipulation method (default: burg)
methodLPC$ = &amp;#34;burg&amp;#34;
### Define your fade-in/fade-out overlap window in seconds (default: 0.01)
window = 0.01





################################################################################
### Let&amp;#39;s check whether the directories specified above exist...
################################################################################

### Let&amp;#39;s check if the input directory exists.
### This script will throw an error if the directory doesn&amp;#39;t exist
### (i.e., it won&amp;#39;t write to a mysterious temp directory).

### First check whether the input directory ends in a backslash (if so, removed)

if right$(dir_in$,1)=&amp;#34;/&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
elsif right$(dir_in$,1)=&amp;#34;\&amp;#34;
	dir_in$ = left$(dir_in$,length(dir_in$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_in$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete it.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_in$&amp;#39; was not found
	exit Your input directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif

## Now re-do this for the output directory:

if right$(dir_out$,1)=&amp;#34;/&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
elsif right$(dir_out$,1)=&amp;#34;\&amp;#34;
	dir_out$ = left$(dir_out$,length(dir_out$)-1)
endif

### Then create a temporary txt file in the folder
### and try to write it to the input folder.

### NOTE: The &amp;#34;nocheck&amp;#34; below asks Praat not to complain if the folder
### does *not* exist. We&amp;#39;ll manually check whether the saving of this
### temp txt file has succeeded or not further down below.

temp_filename$ = dir_out$ + &amp;#34;/&amp;#34; + &amp;#34;my_temporary_Praat_file.txt&amp;#34;
nocheck writeFileLine: temp_filename$, &amp;#34;This is just to check if the directory exists&amp;#34;

### Can the file be found?

file_exists_yesno = fileReadable(temp_filename$)

if file_exists_yesno = 1
	# if you *could* read that temp txt file,
	# this confirms that the directory is valid.
	# Then you can delete that temp txt file.
	deleteFile: temp_filename$
else
	# if that file wasn&amp;#39;t readable, that means that the directory wasn&amp;#39;t valid. 
	printline The folder &amp;#39;dir_out$&amp;#39; was not found
	exit Your output directory doesn&amp;#39;t exist. Check spelling. The directory must *already* exist.
endif





################################################################################
################################################################################
#################################    SCRIPT    #################################
################################################################################
################################################################################

## Let&amp;#39;s clear the Info window so we can print fresh new log data of our stimuli.
## This log prints for each pair of items (&amp;#34;item&amp;#34;), for each created step,
##		the original word duration, vowel duration, mean f0, f1, f2, f3 for the 1st member of the item pair
##		the original word duration, vowel duration, mean f0, f1, f2, f3 for the 2nd member of the item pair
##		the word duration, vowel duration, mean f0, f1, f2, f3 for the manipulated output sound.
clearinfo
echo item	step	dur_1	voweldur_1	f0_1	f1_1	f2_1	f3_1	dur_2	voweldur_2	f0_2	f1_2	f2_2	f3_2	dur_manip	voweldur_manip	f0_manip	f1_manip	f2_manip	f3_manip





Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;table_name$&amp;#39;.txt
nItems = Get number of rows

for ItemCnt from 1 to nItems
	## Create leading and trailing silence of 0.5 sec to append to the words to
	## improve spectral measurements at the onset/offset of the words.
	Create Sound from formula... silence1 Mono 0 0.5 cutoff  0

	#######################################
	## Read and measure acoustics of word1
	#######################################

	select Table &amp;#39;table_name$&amp;#39;
	word1$ = Get value... &amp;#39;ItemCnt&amp;#39; word1
	word2$ = Get value... &amp;#39;ItemCnt&amp;#39; word2
	
	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word1$&amp;#39;.wav
	Rename... word1
	sampFreq_1 = Get sampling frequency
	dur_1 = Get total duration
	int_1 = Get intensity (dB)
	To Pitch... 0 &amp;#39;minpitch&amp;#39; &amp;#39;maxpitch&amp;#39;
	f0_1 = Get mean... 0 0 Hertz

	select Sound word1
	Resample: cutoff, 50
	Rename... word1_belowcutoff
	select Sound word1
	Remove

	Create Sound from formula... silence2 Mono 0 0.5 cutoff  0
	select Sound silence1
	plus Sound word1_belowcutoff
	plus Sound silence2
	Concatenate
	Rename... word1_pad

	Filter (pass Hann band)... 0 filter 10
	Rename... Low_Part_1
	lowInt_1 = Get intensity (dB)
	To Intensity... 100 0 no
	Down to IntensityTier
	select Intensity Low_Part_1
	Remove

	select Sound word1_pad
	To LPC (burg): (&amp;#39;nformants&amp;#39;*2), 0.025, 0.005, 50
	select Sound word1_pad
	plus LPC word1_pad
	Filter (inverse)
	Rename... Source_1
	select LPC word1_pad
	Remove
	
	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word1$&amp;#39;.TextGrid
	Rename... word1
	Shift times by... 0.5
	vowelonset_1 = Get start time of interval... 1 2
	voweloffset_1 = Get end time of interval... 1 2
	voweldur_1 = voweloffset_1 - vowelonset_1

	select Sound word1_pad
	To Formant (&amp;#39;methodLPC$&amp;#39;)... 0 nformants (cutoff/2) 0.025 50
	maxForm = Get maximum number of formants
	for formCnt from 1 to maxForm
		origFormantsArray_1 [&amp;#39;formCnt&amp;#39;] = Get mean... &amp;#39;formCnt&amp;#39; &amp;#39;vowelonset_1&amp;#39; &amp;#39;voweloffset_1&amp;#39; hertz
		f&amp;#39;formCnt&amp;#39;_1 = Get mean... &amp;#39;formCnt&amp;#39; &amp;#39;vowelonset_1&amp;#39; &amp;#39;voweloffset_1&amp;#39; hertz
	endfor
	Remove
	
	
	
	
	
	#######################################
	## Read and measure acoustics of word2
	#######################################

	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word2$&amp;#39;.wav
	Rename... word2
	sampFreq_2 = Get sampling frequency
	dur_2 = Get total duration
	int_2 = Get intensity (dB)
	To Pitch... 0 &amp;#39;minpitch&amp;#39; &amp;#39;maxpitch&amp;#39;
	f0_2 = Get mean... 0 0 Hertz

	select Sound word2
	Resample: cutoff, 50
	Rename... word2_belowcutoff
	select Sound word2
	Remove

	Create Sound from formula... silence2 Mono 0 0.5 cutoff  0
	select Sound silence1
	plus Sound word2_belowcutoff
	plus Sound silence2
	Concatenate
	Rename... word2_pad

	Filter (pass Hann band)... 0 filter 10
	Rename... Low_Part_2
	lowInt_2 = Get intensity (dB)
	To Intensity... 100 0 no
	Down to IntensityTier
	select Intensity Low_Part_2
	Remove

	select Sound word2_pad
	To LPC (burg): (&amp;#39;nformants&amp;#39;*2), 0.025, 0.005, 50
	select Sound word2_pad
	plus LPC word2_pad
	Filter (inverse)
	Rename... Source_2
	select LPC word2_pad
	Remove

	Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word2$&amp;#39;.TextGrid
	Rename... word2
	Shift times by... 0.5
	vowelonset_2 = Get start time of interval... 1 2
	voweloffset_2 = Get end time of interval... 1 2
	voweldur_2 = voweloffset_2 - vowelonset_2

	select Sound word2_pad
	To Formant (&amp;#39;methodLPC$&amp;#39;)... 0 nformants (cutoff/2) 0.025 50
	maxForm = Get maximum number of formants
	for formCnt from 1 to maxForm
		origFormantsArray_2 [&amp;#39;formCnt&amp;#39;] = Get mean... &amp;#39;formCnt&amp;#39; &amp;#39;vowelonset_2&amp;#39; &amp;#39;voweloffset_2&amp;#39; hertz
		f&amp;#39;formCnt&amp;#39;_2 = Get mean... &amp;#39;formCnt&amp;#39; &amp;#39;vowelonset_2&amp;#39; &amp;#39;voweloffset_2&amp;#39; hertz
	endfor
	Remove
	
	
	

	
	#######################################
	## Now loop over steps
	#######################################

	for stepCtr from 1 to nSteps

		# NOTE: we take word1 (here: the high-F1 member [bet]) as the basis for the manipulations.

		select Sound word1_pad
		To Formant (&amp;#39;methodLPC$&amp;#39;)... 0 nformants (cutoff/2) 0.025 50
		maxForm = Get maximum number of formants
		nFrames = Get number of frames
		Rename: &amp;#34;New_Form_&amp;#39;stepCtr&amp;#39;&amp;#34;

		###############################################################################################################
		# if some items need custom formant shifts, you can define an item-specific constant here
		###############################################################################################################
		constant = 0
		#	if word1$ = &amp;#34;bet&amp;#34;
		#		constant = 30
		#	elsif word1$ = &amp;#34;get&amp;#34;
		#		constant = 50
		#	elsif word1$ = &amp;#34;set&amp;#34;
		#		constant = 40
		#	endif

		## NOTE: we create a continuum starting at the high-F1 member (on step 1)
		##	gradually going do to the low-F1 member.
		stepsize = (f1_1 - f1_2)/(nSteps-1)
		Formula (frequencies): &amp;#34;if row = 1 then (self-(((stepCtr-1)*stepsize)+constant)) else self fi&amp;#34;
		
		## You can also control other formants, for instance by setting the F2 to the average of the two vowels
		## thus creating an ambiguous F2 in between the two vowels that is fixed/constant at every step.
		## For instance:

		#ambF2 = (f2_1 + f2_2)/2
		#distanceToAmbF2 = f2_1 - ambF2
		#Formula (frequencies): &amp;#34;if row = 2 then (self-distanceToAmbF2) else self fi&amp;#34;
		
		## Filter the original source with the new formant filter
		select Formant New_Form_&amp;#39;stepCtr&amp;#39;
		plus Sound Source_1
		Filter

		## Restrict to lower-freq content only
		Filter (pass Hann band)... 0 filter 10
		Rename... word1_&amp;#39;stepCtr&amp;#39;_Low

		## Transplant the original intensity contour back onto the manipulated speech
		To Intensity... 100 0 no
		Down to IntensityTier
		Formula... self*-1
		plus Sound word1_&amp;#39;stepCtr&amp;#39;_Low
		Multiply... yes
		plus IntensityTier Low_Part_1
		Multiply... yes
		Scale intensity... lowInt_1

		## Remove leading and trailing silences
		Extract part: 0.5, (dur_1+0.5), &amp;#34;rectangular&amp;#34;, 1, &amp;#34;no&amp;#34;
		Resample: sampFreq_1, 50
		Rename... word1_&amp;#39;stepCtr&amp;#39;_Low_nonpad

		## Combine with the original high-freq content
		Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word1$&amp;#39;.wav
		Rename... word1
		Filter (pass Hann band)... filter sampFreq_1 10
		Rename... word1_High
		plus Sound word1_&amp;#39;stepCtr&amp;#39;_Low_nonpad
		Combine to stereo
		Convert to mono
		Rename... word1_&amp;#39;stepCtr&amp;#39;_manip
		Scale intensity... int_1
		selectObject: &amp;#34;Sound word1&amp;#34;
		Scale intensity... int_1

		select Sound word1_&amp;#39;stepCtr&amp;#39;_manip
		dur_manip = Get total duration
		To Manipulation... 0.01 &amp;#39;minpitch&amp;#39; &amp;#39;maxpitch&amp;#39;
		Extract pitch tier
		f0_manip = Get mean (curve)... 0 0

		## Set the F0 to the average values across word1 &amp;amp; word2
		if control_f0$ = &amp;#34;yes&amp;#34;
			newWordF0 = (f0_1+f0_2)/2
			f0ScalingFactor = newWordF0/f0_manip

			select Manipulation word1_&amp;#39;stepCtr&amp;#39;_manip
			Extract pitch tier
			Multiply frequencies... 0 1000 &amp;#39;f0ScalingFactor&amp;#39;
			f0_manip = Get mean (curve)... 0 0
			plus Manipulation word1_&amp;#39;stepCtr&amp;#39;_manip
			Replace pitch tier
			select Manipulation word1_&amp;#39;stepCtr&amp;#39;_manip
			Get resynthesis (overlap-add)
			Rename... word1_&amp;#39;stepCtr&amp;#39;_manip
		endif
		
		## We&amp;#39;ve shifted the formants in the entire word but we really only want to keep
		## the critical manipulated vowel only. So here we combine:
		## 1. the original pre-vowel interval
		## 2. the manipulated vowel interval
		## 3. the original post-vowel interval
		## using a switch (man1Orig0Switch) that starts at 0 (set to original unmanipulated)
		## and switches back and forth to 1 (manipulated), then 0, etc.

		Read from file... &amp;#39;dir_in$&amp;#39;\&amp;#39;word1$&amp;#39;.TextGrid
		Rename... word1
		nInterv = Get number of intervals: 1
		man1Orig0Switch = 0
		for intervCnt from 1 to nInterv
			selectObject: &amp;#34;TextGrid word1&amp;#34;
			
			intSta = Get start point: 1, intervCnt
			intEnd = Get end point: 1, intervCnt
			if intervCnt = 1
				intSta2 = intSta
				intEnd2 = intEnd + (window/2)
			elsif intervCnt = nInterv
				intSta2 = intSta - (window/2)
				intEnd2 = intEnd
			elsif intervCnt = 2
				intSta2 = intSta - (window/2)
				intEnd2 = intEnd + (window/2)
				vowelonset = intSta
				voweloffset = intEnd
				voweldur_manip = intEnd-intSta
			endif

			if man1Orig0Switch = 0
				selectObject: &amp;#34;Sound word1&amp;#34;
				Extract part: intSta2, intEnd2, &amp;#34;rectangular&amp;#34;, 1, &amp;#34;no&amp;#34;
				Rename... &amp;#39;intervCnt&amp;#39;
				man1Orig0Switch = 1
			elsif man1Orig0Switch = 1
				selectObject: &amp;#34;Sound word1_&amp;#39;stepCtr&amp;#39;_manip&amp;#34;
				Extract part: intSta2, intEnd2, &amp;#34;rectangular&amp;#34;, 1, &amp;#34;no&amp;#34;
				Rename... &amp;#39;intervCnt&amp;#39;
				man1Orig0Switch = 0
			endif
		endfor

		selectObject: &amp;#34;Sound 1&amp;#34;
		for intervCnt_2 from 2 to nInterv
			plusObject: &amp;#34;Sound &amp;#39;intervCnt_2&amp;#39;&amp;#34;
		endfor
		Concatenate with overlap... &amp;#39;window&amp;#39;
		Rename... Resynth____&amp;#39;stepCtr&amp;#39;

		## Save the final result sound
		Save as WAV file: &amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;word1$&amp;#39;_step&amp;#39;stepCtr&amp;#39;.wav&amp;#34;
		selectObject: &amp;#34;TextGrid word1&amp;#34;
		Save as text file: &amp;#34;&amp;#39;dir_out$&amp;#39;\&amp;#39;word1$&amp;#39;_step&amp;#39;stepCtr&amp;#39;.TextGrid&amp;#34;
		
		# Let&amp;#39;s query the F1, F2, F3, F4 for the manipulated vowel interval
		select Formant New_Form_&amp;#39;stepCtr&amp;#39;
		f1_manip = Get mean... 1 (vowelonset+0.5) ((voweloffset)+0.5) hertz
		f2_manip = Get mean... 2 (vowelonset+0.5) ((voweloffset)+0.5) hertz
		f3_manip = Get mean... 3 (vowelonset+0.5) ((voweloffset)+0.5) hertz
		f4_manip = Get mean... 4 (vowelonset+0.5) ((voweloffset)+0.5) hertz
		
		select Sound Resynth____&amp;#39;stepCtr&amp;#39;
		dur_manip = Get total duration
			
		printline &amp;#39;word1$&amp;#39;	&amp;#39;stepCtr&amp;#39;	&amp;#39;dur_1&amp;#39;	&amp;#39;voweldur_1&amp;#39;	&amp;#39;f0_1&amp;#39;	&amp;#39;f1_1&amp;#39;	&amp;#39;f2_1&amp;#39;	&amp;#39;f3_1&amp;#39;	&amp;#39;dur_2&amp;#39;	&amp;#39;voweldur_2&amp;#39;	&amp;#39;f0_2&amp;#39;	&amp;#39;f1_2&amp;#39;	&amp;#39;f2_2&amp;#39;	&amp;#39;f3_2&amp;#39;	&amp;#39;dur_manip&amp;#39;	&amp;#39;voweldur_manip&amp;#39;	&amp;#39;f0_manip&amp;#39;	&amp;#39;f1_manip&amp;#39;	&amp;#39;f2_manip&amp;#39;	&amp;#39;f3_manip&amp;#39;
	endfor

	select all
	minus Table &amp;#39;table_name$&amp;#39;
	Remove
endfor



################################################################################
# End of script
################################################################################
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
